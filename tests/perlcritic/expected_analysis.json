{
  "comments" : [
    {
      "comment" : "perl5.general.perlcritic",
      "params" : {
        "description" : "Missing strict or warnings",
        "diagnostics" : "The [strict](https://metacpan.org/pod/strict) and [warnings](https://metacpan.org/pod/warnings) pragmas help avoid many common pitfalls such as\nmisspellings, scoping issues, and performing operations on undefined values.\nWarnings can also alert you to deprecated or experimental functionality. The\npragmas may either be explicitly imported with `use`, or indirectly through a\nnumber of importer modules such as [Moose](https://metacpan.org/pod/Moose) or [strictures](https://metacpan.org/pod/strictures). [strict](https://metacpan.org/pod/strict) is also\nenabled automatically with a `use` declaration of perl version 5.12 or higher,\nas is [warnings](https://metacpan.org/pod/warnings) with a `use` declaration of 5.36 or higher.\n\n    use strict;\n    use warnings;\n\n    use Moose;\n\n    use 5.012;\n    use warnings;\n\n    use 5.036;\n\nThis policy is similar to the core policies\n[Perl::Critic::Policy::TestingAndDebugging::RequireUseStrict](https://metacpan.org/pod/Perl%3A%3ACritic%3A%3APolicy%3A%3ATestingAndDebugging%3A%3ARequireUseStrict) and\n[Perl::Critic::Policy::TestingAndDebugging::RequireUseWarnings](https://metacpan.org/pod/Perl%3A%3ACritic%3A%3APolicy%3A%3ATestingAndDebugging%3A%3ARequireUseWarnings), but combines\nthem into one policy in the `community` theme. The default modules recognized\nas importing [strict](https://metacpan.org/pod/strict) and [warnings](https://metacpan.org/pod/warnings) are defined by the same constants as the\ncore policies, [\"@STRICT\\_EQUIVALENT\\_MODULES\" in Perl::Critic::Utils::Constants](https://metacpan.org/pod/Perl%3A%3ACritic%3A%3AUtils%3A%3AConstants#STRICT_EQUIVALENT_MODULES).\nTo define additional modules, see [\"CONFIGURATION\"](#configuration).",
        "filename" : "/opt/analyzer/tests/perlcritic/lib/HelloWorld.pm",
        "line_number" : 1,
        "policy" : "Perl::Critic::Policy::Community::StrictWarnings"
      },
      "type" : "actionable"
    },
    {
      "comment" : "perl5.general.perlcritic",
      "params" : {
        "description" : "Subroutine \"hello\" does not end with \"return\"",
        "diagnostics" : "Require all subroutines to terminate explicitly with one of the\nfollowing: `return`, `carp`, `croak`, `die`, `exec`, `exit`,\n`goto`, or `throw`.\n\nSubroutines without explicit return statements at their ends can be\nconfusing.  It can be challenging to deduce what the return value will\nbe.\n\nFurthermore, if the programmer did not mean for there to be a\nsignificant return value, and omits a return statement, some of the\nsubroutine's inner data can leak to the outside.  Consider this case:\n\n    package Password;\n    # every time the user guesses the password wrong, its value\n    # is rotated by one character\n    my $password;\n    sub set_password {\n        $password = shift;\n    }\n    sub check_password {\n        my $guess = shift;\n        if ($guess eq $password) {\n            unlock_secrets();\n        } else {\n            $password = (substr $password, 1).(substr $password, 0, 1);\n        }\n    }\n    1;\n\nIn this case, the last statement in check\\_password() is the\nassignment.  The result of that assignment is the implicit return\nvalue, so a wrong guess returns the right password!  Adding a\n`return;` at the end of that subroutine solves the problem.\n\nThe only exception allowed is an empty subroutine.\n\nBe careful when fixing problems identified by this Policy; don't\nblindly put a `return;` statement at the end of every subroutine.",
        "filename" : "/opt/analyzer/tests/perlcritic/lib/HelloWorld.pm",
        "line_number" : 6,
        "policy" : "Perl::Critic::Policy::Subroutines::RequireFinalReturn"
      },
      "type" : "actionable"
    },
    {
      "comment" : "perl5.general.perlcritic",
      "params" : {
        "description" : "\"grep\" used in void context",
        "diagnostics" : "`map` and `grep` are intended to be pure functions, not mutators.\nIf you want to iterate with side-effects, then you should use a proper\n`for` or `foreach` loop.\n\n    grep{ print frobulate($_) } @list;           #not ok\n    print map{ frobulate($_) } @list;            #ok\n\n    grep{ $_ = lc $_ } @list;                    #not ok\n    for( @list ){ $_ = lc $_  };                 #ok\n\n    map{ push @frobbed, frobulate($_) } @list;   #not ok\n    @frobbed = map { frobulate($_) } @list;      #ok",
        "filename" : "/opt/analyzer/tests/perlcritic/lib/HelloWorld.pm",
        "line_number" : 7,
        "policy" : "Perl::Critic::Policy::BuiltinFunctions::ProhibitVoidGrep"
      },
      "type" : "actionable"
    }
  ]
}
